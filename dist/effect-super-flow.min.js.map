{"version":3,"file":"effect-super-flow.min.js","names":["window","SwiperElementRegisterParams","swiper","on","extendParams","superFlowEffect","fragments","fragmentBorderWidth","fragmentBlur","contentOffset","contentScale","scaleDuration","mainImageScale","level1Scale","level2Scale","level3Scale","animationInSlideIndex","getSlideIndex","slideEl","params","loop","virtual","enabled","parseInt","getAttribute","Array","from","slides","indexOf","getFragmentsByLevel","fragmentsEl","querySelector","fragmentsChildren","children","level1Fragments","map","i","filter","Boolean","level2Fragments","level3Fragments","allFragments","getTranslate","v","isHorizontal","setTranslate","rtlTranslate","rtl","size","length","slideIndex","contentEl","imagesContainerEl","progress","offset","imageScale","imageOffset","fragmentsScale","fragmentsOffset","level1Offset","level2Offset","level3Offset","rtlMultiplier","translate","Math","min","abs","style","transform","forEach","el","zIndex","percents","left","right","getClipPath","side","level","borderWidth","top","bottom","random","push","points","borderClipPath","imageClipPath","p","axis","join","animate","find","realIndex","activeIndex","toString","mainImageEl","transitionDuration","transitionTimingFunction","clientLeft","justTouched","s","hasBlur","querySelectorAll","mainImage","fragmentEl","remove","isTop","clipPath","document","createElement","classList","add","appendChild","max","imageEl","cloneNode","borderEl","initialSlide","requestAnimationFrame","index","effect","setTransition","overwriteParams","perspective","recreateShadows","getEffectParams","requireUpdateOnVirtual","classNames","containerModifierClass","overwriteParamsResult","Object","assign","originalParams","_s","duration","slideShadows","shadowEl","effectInit","addToSelector","_ref","transformElements","virtualTranslate","transitionEndTarget","eventTriggered","callback","addEventListener","fireCallBack","e","target","call","removeEventListener","elementTransitionEnd","destroyed","animating","evt","CustomEvent","bubbles","cancelable","wrapperEl","dispatchEvent","effectVirtualTransitionEnd","newBreakpoints","passedParams","breakpoints","keys","key","slidesPerView","spaceBetween","centeredSlides","slidesPerGroup","watchSlidesProgress"],"sources":["../demo-vite/effect-super-flow.esm.js","../node_modules/swiper/shared/effect-init.mjs","../node_modules/swiper/shared/effect-virtual-transition-end.mjs","../node_modules/swiper/shared/utils.mjs"],"sourcesContent":["import { effectInit, effectVirtualTransitionEnd } from 'swiper/effect-utils';\n\nif (typeof window !== 'undefined' && window.SwiperElementRegisterParams) {\n  window.SwiperElementRegisterParams(['superFlowEffect']);\n}\n\nexport default function EffectSuperFlow({ swiper, on, extendParams }) {\n  extendParams({\n    superFlowEffect: {\n      fragments: 3,\n      fragmentBorderWidth: 1,\n      fragmentBlur: false,\n      contentOffset: 5,\n      contentScale: 1.2,\n      scaleDuration: 10000,\n      mainImageScale: 1.1,\n      level1Scale: 1.15,\n      level2Scale: 1.2,\n      level3Scale: 1.25,\n    },\n  });\n  let animationInSlideIndex = null;\n\n  const getSlideIndex = (slideEl) => {\n    if (\n      swiper.params.loop ||\n      (swiper.params.virtual && swiper.virtual && swiper.params.virtual.enabled)\n    ) {\n      return parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      const index = Array.from(swiper.slides).indexOf(slideEl);\n      return index;\n    }\n  };\n\n  const getFragmentsByLevel = (slideEl) => {\n    const fragmentsEl = slideEl.querySelector('.super-flow-fragments');\n    const fragmentsChildren = fragmentsEl ? [...fragmentsEl.children] : [];\n    const level1Indexes = [0, 1, 6, 7];\n    const level2Indexes = [2, 3, 8, 9];\n    const level3Indexes = [4, 5, 10, 11];\n    const level1Fragments = level1Indexes\n      .map((i) => fragmentsChildren[i])\n      .filter(Boolean);\n    const level2Fragments = level2Indexes\n      .map((i) => fragmentsChildren[i])\n      .filter(Boolean);\n    const level3Fragments = level3Indexes\n      .map((i) => fragmentsChildren[i])\n      .filter(Boolean);\n    return {\n      allFragments: fragmentsChildren,\n      level1Fragments,\n      level2Fragments,\n      level3Fragments,\n    };\n  };\n\n  const getTranslate = (v = 0) => {\n    const isHorizontal = swiper.isHorizontal();\n    return isHorizontal ? `translate(${v}, 0)` : `translate(0, ${v})`;\n  };\n\n  const setTranslate = () => {\n    const { slides, rtlTranslate: rtl } = swiper;\n    const { size } = swiper;\n\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideIndex = getSlideIndex(slideEl);\n      const contentEl = slideEl.querySelector('.super-flow-content');\n      const imagesContainerEl = slideEl.querySelector('.super-flow-image');\n      const fragmentsEl = slideEl.querySelector('.super-flow-fragments');\n      const { level1Fragments, level2Fragments, level3Fragments } =\n        getFragmentsByLevel(slideEl);\n      const progress = slideEl.progress;\n      let offset;\n      let imageScale = 1;\n      let imageOffset = 0;\n      let fragmentsScale = 1;\n      let fragmentsOffset = 0;\n      let contentOffset = 0;\n      let level1Offset = 0;\n      let level2Offset = 0;\n      let level3Offset = 0;\n      const rtlMultiplier = rtl ? -1 : 1;\n      if (progress <= 0) {\n        // next slides\n        contentOffset =\n          -swiper.params.superFlowEffect.contentOffset * rtlMultiplier;\n        offset = size * progress + swiper.translate * rtlMultiplier;\n        imageScale = 1.1 - 0.1 * Math.min(1, Math.abs(progress));\n        imageOffset = 20 * rtlMultiplier * Math.min(1, Math.abs(progress));\n        fragmentsScale = 0.95 + 0.05 * Math.min(1, Math.abs(progress));\n        level1Offset = 30 * rtlMultiplier * Math.min(1, Math.abs(progress));\n        level2Offset = 20 * rtlMultiplier * Math.min(1, Math.abs(progress));\n        level3Offset = 10 * rtlMultiplier * Math.min(1, Math.abs(progress));\n      } else {\n        // current slide\n        offset =\n          (swiper.translate -\n            Math.min(progress, 1) * size * 0.09 * rtlMultiplier) *\n          rtlMultiplier;\n        imageScale = 1.1;\n        fragmentsOffset = 5 * Math.min(1, Math.abs(progress));\n        fragmentsScale = 0.95;\n      }\n\n      if (rtl) {\n        offset = -offset;\n      }\n      if (imagesContainerEl) {\n        imagesContainerEl.style.transform = `scale(${imageScale}) ${getTranslate(imageOffset + '%')}`;\n      }\n      if (fragmentsEl) {\n        fragmentsEl.style.transform = `scale(${fragmentsScale}) ${getTranslate(fragmentsOffset + '%')}`;\n      }\n\n      if (slideIndex !== animationInSlideIndex) {\n        if (contentEl) {\n          contentEl.style.transform = getTranslate(`${contentOffset}%`);\n        }\n        level1Fragments.forEach((el) => {\n          el.style.transform = getTranslate(level1Offset + '%');\n        });\n        level2Fragments.forEach((el) => {\n          el.style.transform = getTranslate(level2Offset + '%');\n        });\n        level3Fragments.forEach((el) => {\n          el.style.transform = getTranslate(level3Offset + '%');\n        });\n      }\n\n      slideEl.style.transform = getTranslate(offset + 'px');\n      slideEl.style.zIndex = swiper.slides.length - i;\n    }\n  };\n\n  const setTransition = (duration) => {\n    const { slides } = swiper;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideIndex = getSlideIndex(slideEl);\n      let addToSelector = '';\n      if (slideIndex !== animationInSlideIndex) {\n        addToSelector =\n          ', .super-flow-image img, .super-flow-fragment, .super-flow-fragment-border,  .super-flow-content';\n      }\n      [\n        slideEl,\n        ...slideEl.querySelectorAll(\n          `.super-flow-fragments, .super-flow-image${addToSelector}`,\n        ),\n      ].forEach((el) => {\n        el.style.transitionDuration = `${duration}ms`;\n      });\n    }\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements: slides,\n      allSlides: true,\n    });\n  };\n\n  const percents = {\n    left: [],\n    right: [],\n  };\n  const getClipPath = (side, level, borderWidth) => {\n    let top = 0;\n    let bottom = 0;\n    if (side === 'left') {\n      if (level === 0) {\n        top = 20 + Math.random() * 5;\n        bottom = 5 + Math.random() * 5;\n        percents.left.push([top, bottom]);\n      } else if (level === 1) {\n        top = 5 + Math.random() * 5;\n        bottom = 10 + Math.random() * 10;\n      } else if (level === 2) {\n        top = percents.left[0][0] - Math.random() * 10;\n        bottom = percents.left[0][1] - Math.random() * 5;\n      }\n    }\n    if (side === 'right') {\n      if (level === 0) {\n        top = 5 + Math.random() * 5;\n        bottom = 20 + Math.random() * 10;\n        percents.right.push([top, bottom]);\n      } else if (level === 1) {\n        top = 10 + Math.random() * 10;\n        bottom = 5 + Math.random() * 5;\n      } else if (level === 2) {\n        top = percents.right[0][0] - Math.random() * 5;\n        bottom = percents.right[0][1] - Math.random() * 10;\n      }\n    }\n    const points =\n      side === 'left'\n        ? [\n            [0, 0],\n            [top, 0],\n            [bottom, 100],\n            [0, 100],\n          ]\n        : [\n            [100, 0],\n            [100 - top, 0],\n            [100 - bottom, 100],\n            [100, 100],\n          ];\n    let borderClipPath = '';\n    let imageClipPath = '';\n    if (side === 'left') {\n      borderClipPath = `polygon(${points.map((p) => p.map((el, axis) => (axis === 0 ? `calc(${el}% + ${borderWidth}px)` : `${el}%`)).join(' ')).join(',')})`;\n    }\n    if (side === 'right') {\n      borderClipPath = `polygon(${points.map((p) => p.map((el, axis) => (axis === 0 ? `calc(${el}% - ${borderWidth}px)` : `${el}%`)).join(' ')).join(',')})`;\n    }\n    imageClipPath = `polygon(${points.map((p) => p.map((el) => `${el}%`).join(' ')).join(',')})`;\n    return { borderClipPath, imageClipPath };\n  };\n  const createFragments = (s) => {\n    const borderWidth = s.params.superFlowEffect.fragmentBorderWidth;\n    const hasBlur = s.params.superFlowEffect.fragmentBlur;\n    const isHorizontal = swiper.isHorizontal();\n    const rtl = swiper.rtlTranslate;\n    swiper.el.querySelectorAll('.super-flow-image').forEach((el) => {\n      const mainImage = el.querySelector('img:not(.super-flow-fragment)');\n      if (!mainImage) return;\n      el.querySelectorAll(\n        '.super-flow-fragment, .super-flow-fragment-border',\n      ).forEach((fragmentEl) => {\n        fragmentEl.remove();\n      });\n      // set main image clip path\n      const isTop = Math.random() > 0.5;\n      const offset = (5 + Math.random() * 4) / 2;\n      const points = isHorizontal\n        ? rtl\n          ? [\n              [isTop ? offset : 0, 0],\n              [100, 0],\n              [100, 100],\n              [!isTop ? offset : 0, 100],\n            ]\n          : [\n              [0, 0],\n              [isTop ? 100 - offset : 100, 0],\n              [!isTop ? 100 - offset : 100, 100],\n              [0, 100],\n            ]\n        : [\n            [0, 0],\n            [100, 0],\n            [100, isTop ? 100 - offset : 100],\n            [0, !isTop ? 100 - offset : 100],\n          ];\n      el.style.clipPath = `polygon(${points.map((p) => p.map((el) => `${el}%`).join(' ')).join(',')})`;\n      const fragmentsEl = document.createElement('div');\n      fragmentsEl.classList.add('super-flow-fragments');\n      el.appendChild(fragmentsEl);\n\n      const fragments = Math.min(\n        Math.max(0, s.params.superFlowEffect.fragments),\n        3,\n      );\n\n      // add left edges\n      for (let i = 0; i < fragments; i += 1) {\n        const imageEl = mainImage.cloneNode(true);\n        const borderEl = document.createElement('div');\n        imageEl.classList.add('super-flow-fragment');\n        borderEl.classList.add('super-flow-fragment-border');\n        const { borderClipPath, imageClipPath } = getClipPath(\n          'left',\n          i,\n          borderWidth,\n        );\n        borderEl.style.clipPath = borderClipPath;\n        imageEl.style.clipPath = imageClipPath;\n        if (hasBlur) {\n          imageEl.style.filter = `blur(${i + 1}px)`;\n        }\n        fragmentsEl.appendChild(borderEl);\n        fragmentsEl.appendChild(imageEl);\n      }\n\n      // add right edges\n      for (let i = 0; i < fragments; i += 1) {\n        const imageEl = mainImage.cloneNode(true);\n        const borderEl = document.createElement('div');\n        imageEl.classList.add('super-flow-fragment');\n        borderEl.classList.add('super-flow-fragment-border');\n        const { borderClipPath, imageClipPath } = getClipPath(\n          'right',\n          i,\n          borderWidth,\n        );\n        borderEl.style.clipPath = borderClipPath;\n        imageEl.style.clipPath = imageClipPath;\n        if (hasBlur) {\n          imageEl.style.filter = `blur(${i + 1}px)`;\n        }\n        fragmentsEl.appendChild(borderEl);\n        fragmentsEl.appendChild(imageEl);\n      }\n    });\n  };\n\n  const cleanUp = () => {\n    const otherSlideEls = swiper.slides.filter((el, index) => {\n      const slideIndex = getSlideIndex(el);\n      const compareIndex = swiper.params.loop\n        ? swiper.realIndex\n        : swiper.activeIndex;\n      return slideIndex !== compareIndex;\n    });\n\n    otherSlideEls.forEach((el, index) => {\n      el.querySelectorAll(\n        'img, .super-flow-fragment, .super-flow-fragment-border',\n      ).forEach((el) => {\n        el.style.transitionDuration = '0ms';\n        el.style.transform = '';\n      });\n    });\n  };\n\n  const animate = () => {\n    const isVirtual =\n      swiper.params.virtual && swiper.virtual && swiper.params.virtual.enabled;\n    const slideEl = isVirtual\n      ? swiper.slides.find(\n          (el) =>\n            el.getAttribute('data-swiper-slide-index') ===\n            (swiper.params.loop\n              ? swiper.realIndex\n              : swiper.activeIndex\n            ).toString(),\n        )\n      : swiper.slides[swiper.activeIndex];\n\n    const slideIndex = getSlideIndex(slideEl);\n    const rtlMultiplier = swiper.rtlTranslate ? -1 : 1;\n    if (slideIndex === animationInSlideIndex) {\n      return;\n    }\n    animationInSlideIndex = slideIndex;\n\n    const params = swiper.params.superFlowEffect;\n    const {\n      scaleDuration,\n      mainImageScale,\n      level1Scale,\n      level2Scale,\n      level3Scale,\n      contentOffset,\n      contentScale,\n    } = params;\n\n    const mainImageEl = slideEl.querySelector('.super-flow-image > img');\n    const contentEl = slideEl.querySelector('.super-flow-content');\n    const { allFragments, level1Fragments, level2Fragments, level3Fragments } =\n      getFragmentsByLevel(slideEl);\n\n    if (mainImageEl) {\n      mainImageEl.style.transitionDuration = '0ms';\n      mainImageEl.style.transitionTimingFunction = 'linear';\n      mainImageEl.style.transform = `${getTranslate()} scale(1)`;\n    }\n    if (contentEl) {\n      contentEl.style.transitionDuration = '0ms';\n      mainImageEl.style.transitionTimingFunction = 'linear';\n      contentEl.style.transform = getTranslate(\n        `${-contentOffset * rtlMultiplier}%`,\n      );\n    }\n    allFragments.forEach((el) => {\n      el.style.transitionDuration = '0ms';\n      el.style.transform = getTranslate();\n    });\n\n    const clientLeft = slideEl.clientLeft;\n\n    if (mainImageEl) {\n      mainImageEl.style.transitionDuration = `${scaleDuration}ms`;\n      mainImageEl.style.transitionTimingFunction = 'linear';\n      mainImageEl.style.transform = `${getTranslate()} scale(${mainImageScale})`;\n    }\n    if (contentEl) {\n      contentEl.style.transitionDuration = `${scaleDuration}ms`;\n      contentEl.style.transitionTimingFunction = 'linear';\n      contentEl.style.transform = `${getTranslate(`${contentOffset * rtlMultiplier}%`)} scale(${contentScale})`;\n    }\n    allFragments.forEach((el) => {\n      el.style.transitionDuration = `${scaleDuration}ms`;\n      el.style.transitionTimingFunction = 'linear';\n    });\n\n    level1Fragments.forEach((el) => {\n      el.style.transform = `${getTranslate()} scale(${level1Scale})`;\n    });\n    level2Fragments.forEach((el) => {\n      el.style.transform = `${getTranslate()} scale(${level2Scale})`;\n    });\n    level3Fragments.forEach((el) => {\n      el.style.transform = `${getTranslate()} scale(${level3Scale})`;\n    });\n  };\n\n  let justTouched = false;\n\n  const onTouchEnd = () => {\n    justTouched = true;\n    requestAnimationFrame(() => {\n      justTouched = false;\n    });\n  };\n\n  const onTransitionStart = () => {\n    if (justTouched) {\n      return;\n    }\n    animate();\n  };\n\n  const onTransitionEnd = () => {\n    cleanUp();\n    animate();\n  };\n\n  const onInit = () => {\n    if (swiper.params.initialSlide === 0) {\n      animate();\n    }\n  };\n\n  on('beforeInit', createFragments);\n  on('init', onInit);\n  on('touchEnd', onTouchEnd);\n  on('transitionStart', onTransitionStart);\n  on('transitionEnd', onTransitionEnd);\n  on('virtualUpdate', setTranslate);\n  effectInit({\n    effect: 'super-flow',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => false,\n    overwriteParams: () => {\n      let newBreakpoints = {};\n      if (swiper.passedParams.breakpoints) {\n        Object.keys(swiper.passedParams.breakpoints).forEach((key) => {\n          newBreakpoints[key] = {\n            ...swiper.passedParams.breakpoints[key],\n            slidesPerView: 1,\n            spaceBetween: 0,\n          };\n        });\n      }\n      return {\n        virtualTranslate: true,\n        // resizeObserver: false,\n        centeredSlides: false,\n        slidesPerGroup: 1,\n        slidesPerView: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        breakpoints: newBreakpoints,\n      };\n    },\n  });\n}\n","function effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams\n  } = params;\n  on('beforeInit', () => {\n    if (swiper.params.effect !== effect) return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on('setTranslate _virtualUpdated', () => {\n    if (swiper.params.effect !== effect) return;\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    if (swiper.params.effect !== effect) return;\n    setTransition(duration);\n  });\n  on('transitionEnd', () => {\n    if (swiper.params.effect !== effect) return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows) return;\n      // remove shadows\n      swiper.slides.forEach(slideEl => {\n        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n      });\n      // create new one\n      recreateShadows();\n    }\n  });\n  let requireUpdateOnVirtual;\n  on('virtualUpdate', () => {\n    if (swiper.params.effect !== effect) return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\n\nexport { effectInit as e };\n","import { l as elementTransitionEnd } from './utils.mjs';\n\nfunction effectVirtualTransitionEnd(_ref) {\n  let {\n    swiper,\n    duration,\n    transformElements,\n    allSlides\n  } = _ref;\n  const {\n    activeIndex\n  } = swiper;\n  const getSlide = el => {\n    if (!el.parentElement) {\n      // assume shadow root\n      const slide = swiper.slides.find(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode);\n      return slide;\n    }\n    return el.parentElement;\n  };\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let transitionEndTarget;\n    if (allSlides) {\n      transitionEndTarget = transformElements;\n    } else {\n      transitionEndTarget = transformElements.filter(transformEl => {\n        const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n        return swiper.getSlideIndex(el) === activeIndex;\n      });\n    }\n    transitionEndTarget.forEach(el => {\n      elementTransitionEnd(el, () => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const evt = new window.CustomEvent('transitionend', {\n          bubbles: true,\n          cancelable: true\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      });\n    });\n  }\n}\n\nexport { effectVirtualTransitionEnd as e };\n","import { a as getWindow, g as getDocument } from './ssr-window.esm.mjs';\n\nfunction classesToTokens(classes) {\n  if (classes === void 0) {\n    classes = '';\n  }\n  return classes.trim().split(' ').filter(c => !!c.trim());\n}\n\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach(key => {\n    try {\n      object[key] = null;\n    } catch (e) {\n      // no getter for object\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n      // something got wrong\n    }\n  });\n}\nfunction nextTick(callback, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle(el) {\n  const window = getWindow();\n  let style;\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n  return style;\n}\nfunction getTranslate(el, axis) {\n  if (axis === void 0) {\n    axis = 'x';\n  }\n  const window = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n  const curStyle = getComputedStyle(el);\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n    }\n    // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n}\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend() {\n  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  for (let i = 1; i < arguments.length; i += 1) {\n    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== undefined && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll(_ref) {\n  let {\n    swiper,\n    targetPosition,\n    side\n  } = _ref;\n  const window = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n  swiper.wrapperEl.style.scrollSnapType = 'none';\n  window.cancelAnimationFrame(swiper.cssModeFrameID);\n  const dir = targetPosition > startPosition ? 'next' : 'prev';\n  const isOutOfBound = (current, target) => {\n    return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n  };\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.scrollSnapType = '';\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n      });\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n  };\n  animate();\n}\nfunction getSlideTransformEl(slideEl) {\n  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n}\nfunction elementChildren(element, selector) {\n  if (selector === void 0) {\n    selector = '';\n  }\n  const window = getWindow();\n  const children = [...element.children];\n  if (window.HTMLSlotElement && element instanceof HTMLSlotElement) {\n    children.push(...element.assignedElements());\n  }\n  if (!selector) {\n    return children;\n  }\n  return children.filter(el => el.matches(selector));\n}\nfunction elementIsChildOfSlot(el, slot) {\n  // Breadth-first search through all parent's children and assigned elements\n  const elementsQueue = [slot];\n  while (elementsQueue.length > 0) {\n    const elementToCheck = elementsQueue.shift();\n    if (el === elementToCheck) {\n      return true;\n    }\n    elementsQueue.push(...elementToCheck.children, ...(elementToCheck.shadowRoot ? elementToCheck.shadowRoot.children : []), ...(elementToCheck.assignedElements ? elementToCheck.assignedElements() : []));\n  }\n}\nfunction elementIsChildOf(el, parent) {\n  const window = getWindow();\n  let isChild = parent.contains(el);\n  if (!isChild && window.HTMLSlotElement && parent instanceof HTMLSlotElement) {\n    const children = [...parent.assignedElements()];\n    isChild = children.includes(el);\n    if (!isChild) {\n      isChild = elementIsChildOfSlot(el, parent);\n    }\n  }\n  return isChild;\n}\nfunction showWarning(text) {\n  try {\n    console.warn(text);\n    return;\n  } catch (err) {\n    // err\n  }\n}\nfunction createElement(tag, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n  const el = document.createElement(tag);\n  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));\n  return el;\n}\nfunction elementOffset(el) {\n  const window = getWindow();\n  const document = getDocument();\n  const box = el.getBoundingClientRect();\n  const body = document.body;\n  const clientTop = el.clientTop || body.clientTop || 0;\n  const clientLeft = el.clientLeft || body.clientLeft || 0;\n  const scrollTop = el === window ? window.scrollY : el.scrollTop;\n  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n  return {\n    top: box.top + scrollTop - clientTop,\n    left: box.left + scrollLeft - clientLeft\n  };\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if (prev.matches(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if (next.matches(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window = getWindow();\n  return window.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\nfunction elementParents(el, selector) {\n  const parents = []; // eslint-disable-line\n  let parent = el.parentElement; // eslint-disable-line\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector)) parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n  function fireCallBack(e) {\n    if (e.target !== el) return;\n    callback.call(el, e);\n    el.removeEventListener('transitionend', fireCallBack);\n  }\n  if (callback) {\n    el.addEventListener('transitionend', fireCallBack);\n  }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n  const window = getWindow();\n  if (includeMargins) {\n    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n  }\n  return el.offsetWidth;\n}\nfunction makeElementsArray(el) {\n  return (Array.isArray(el) ? el : [el]).filter(e => !!e);\n}\nfunction getRotateFix(swiper) {\n  return v => {\n    if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {\n      return v + 0.001;\n    }\n    return v;\n  };\n}\nfunction setInnerHTML(el, html) {\n  if (html === void 0) {\n    html = '';\n  }\n  if (typeof trustedTypes !== 'undefined') {\n    el.innerHTML = trustedTypes.createPolicy('html', {\n      createHTML: s => s\n    }).createHTML(html);\n  } else {\n    el.innerHTML = html;\n  }\n}\n\nexport { setCSSProperty as a, elementParents as b, createElement as c, elementOffset as d, elementChildren as e, now as f, getSlideTransformEl as g, elementOuterSize as h, elementIndex as i, classesToTokens as j, getTranslate as k, elementTransitionEnd as l, makeElementsArray as m, nextTick as n, isObject as o, getRotateFix as p, elementStyle as q, elementNextAll as r, setInnerHTML as s, elementPrevAll as t, animateCSSModeScroll as u, showWarning as v, elementIsChildOf as w, extend as x, deleteProps as y };\n"],"mappings":";;;;;;;;;;;;;;sPAEsB,oBAAXA,QAA0BA,OAAOC,6BAC1CD,OAAOC,4BAA4B,CAAC,oBAGvB,UAAyBC,OAAEA,EAAMC,GAAEA,EAAEC,aAAEA,IACpDA,EAAa,CACXC,gBAAiB,CACfC,UAAW,EACXC,oBAAqB,EACrBC,cAAc,EACdC,cAAe,EACfC,aAAc,IACdC,cAAe,IACfC,eAAgB,IAChBC,YAAa,KACbC,YAAa,IACbC,YAAa,QAGjB,IAAIC,EAAwB,KAE5B,MAAMC,EAAiBC,IACrB,GACEhB,EAAOiB,OAAOC,MACblB,EAAOiB,OAAOE,SAAWnB,EAAOmB,SAAWnB,EAAOiB,OAAOE,QAAQC,QAElE,OAAOC,SAASL,EAAQM,aAAa,2BAA4B,IAGjE,OADcC,MAAMC,KAAKxB,EAAOyB,QAAQC,QAAQV,EAEtD,EAGQW,EAAuBX,IAC3B,MAAMY,EAAcZ,EAAQa,cAAc,yBACpCC,EAAoBF,EAAc,IAAIA,EAAYG,UAAY,GAI9DC,EAHgB,CAAC,EAAG,EAAG,EAAG,GAI7BC,KAAKC,GAAMJ,EAAkBI,KAC7BC,OAAOC,SACJC,EALgB,CAAC,EAAG,EAAG,EAAG,GAM7BJ,KAAKC,GAAMJ,EAAkBI,KAC7BC,OAAOC,SACJE,EAPgB,CAAC,EAAG,EAAG,GAAI,IAQ9BL,KAAKC,GAAMJ,EAAkBI,KAC7BC,OAAOC,SACV,MAAO,CACLG,aAAcT,EACdE,kBACAK,kBACAC,kBACD,EAGGE,EAAe,CAACC,EAAI,IACHzC,EAAO0C,eACN,aAAaD,QAAU,gBAAgBA,KAGzDE,EAAe,KACnB,MAAMlB,OAAEA,EAAQmB,aAAcC,GAAQ7C,GAChC8C,KAAEA,GAAS9C,EAEjB,IAAK,IAAIkC,EAAI,EAAGA,EAAIT,EAAOsB,OAAQb,GAAK,EAAG,CACzC,MAAMlB,EAAUS,EAAOS,GACjBc,EAAajC,EAAcC,GAC3BiC,EAAYjC,EAAQa,cAAc,uBAClCqB,EAAoBlC,EAAQa,cAAc,qBAC1CD,EAAcZ,EAAQa,cAAc,0BACpCG,gBAAEA,EAAeK,gBAAEA,EAAeC,gBAAEA,GACxCX,EAAoBX,GAChBmC,EAAWnC,EAAQmC,SACzB,IAAIC,EACAC,EAAa,EACbC,EAAc,EACdC,EAAiB,EACjBC,EAAkB,EAClBjD,EAAgB,EAChBkD,EAAe,EACfC,EAAe,EACfC,EAAe,EACnB,MAAMC,EAAgBf,GAAM,EAAK,EAC7BM,GAAY,GAEd5C,GACGP,EAAOiB,OAAOd,gBAAgBI,cAAgBqD,EACjDR,EAASN,EAAOK,EAAWnD,EAAO6D,UAAYD,EAC9CP,EAAa,IAAM,GAAMS,KAAKC,IAAI,EAAGD,KAAKE,IAAIb,IAC9CG,EAAc,GAAKM,EAAgBE,KAAKC,IAAI,EAAGD,KAAKE,IAAIb,IACxDI,EAAiB,IAAO,IAAOO,KAAKC,IAAI,EAAGD,KAAKE,IAAIb,IACpDM,EAAe,GAAKG,EAAgBE,KAAKC,IAAI,EAAGD,KAAKE,IAAIb,IACzDO,EAAe,GAAKE,EAAgBE,KAAKC,IAAI,EAAGD,KAAKE,IAAIb,IACzDQ,EAAe,GAAKC,EAAgBE,KAAKC,IAAI,EAAGD,KAAKE,IAAIb,MAGzDC,GACGpD,EAAO6D,UACNC,KAAKC,IAAIZ,EAAU,GAAKL,EAAO,IAAOc,GACxCA,EACFP,EAAa,IACbG,EAAkB,EAAIM,KAAKC,IAAI,EAAGD,KAAKE,IAAIb,IAC3CI,EAAiB,KAGfV,IACFO,GAAUA,GAERF,IACFA,EAAkBe,MAAMC,UAAY,SAASb,MAAeb,EAAac,EAAc,QAErF1B,IACFA,EAAYqC,MAAMC,UAAY,SAASX,MAAmBf,EAAagB,EAAkB,QAGvFR,IAAelC,IACbmC,IACFA,EAAUgB,MAAMC,UAAY1B,EAAa,GAAGjC,OAE9CyB,EAAgBmC,SAASC,IACvBA,EAAGH,MAAMC,UAAY1B,EAAaiB,EAAe,IAAI,IAEvDpB,EAAgB8B,SAASC,IACvBA,EAAGH,MAAMC,UAAY1B,EAAakB,EAAe,IAAI,IAEvDpB,EAAgB6B,SAASC,IACvBA,EAAGH,MAAMC,UAAY1B,EAAamB,EAAe,IAAI,KAIzD3C,EAAQiD,MAAMC,UAAY1B,EAAaY,EAAS,MAChDpC,EAAQiD,MAAMI,OAASrE,EAAOyB,OAAOsB,OAASb,CACpD,GA8BQoC,EAAW,CACfC,KAAM,GACNC,MAAO,IAEHC,EAAc,CAACC,EAAMC,EAAOC,KAChC,IAAIC,EAAM,EACNC,EAAS,EACA,SAATJ,IACY,IAAVC,GACFE,EAAM,GAAqB,EAAhBf,KAAKiB,SAChBD,EAAS,EAAoB,EAAhBhB,KAAKiB,SAClBT,EAASC,KAAKS,KAAK,CAACH,EAAKC,KACN,IAAVH,GACTE,EAAM,EAAoB,EAAhBf,KAAKiB,SACfD,EAAS,GAAqB,GAAhBhB,KAAKiB,UACA,IAAVJ,IACTE,EAAMP,EAASC,KAAK,GAAG,GAAqB,GAAhBT,KAAKiB,SACjCD,EAASR,EAASC,KAAK,GAAG,GAAqB,EAAhBT,KAAKiB,WAG3B,UAATL,IACY,IAAVC,GACFE,EAAM,EAAoB,EAAhBf,KAAKiB,SACfD,EAAS,GAAqB,GAAhBhB,KAAKiB,SACnBT,EAASE,MAAMQ,KAAK,CAACH,EAAKC,KACP,IAAVH,GACTE,EAAM,GAAqB,GAAhBf,KAAKiB,SAChBD,EAAS,EAAoB,EAAhBhB,KAAKiB,UACC,IAAVJ,IACTE,EAAMP,EAASE,MAAM,GAAG,GAAqB,EAAhBV,KAAKiB,SAClCD,EAASR,EAASE,MAAM,GAAG,GAAqB,GAAhBV,KAAKiB,WAGzC,MAAME,EACK,SAATP,EACI,CACE,CAAC,EAAG,GACJ,CAACG,EAAK,GACN,CAACC,EAAQ,KACT,CAAC,EAAG,MAEN,CACE,CAAC,IAAK,GACN,CAAC,IAAMD,EAAK,GACZ,CAAC,IAAMC,EAAQ,KACf,CAAC,IAAK,MAEd,IAAII,EAAiB,GACjBC,EAAgB,GAQpB,MAPa,SAATT,IACFQ,EAAiB,WAAWD,EAAOhD,KAAKmD,GAAMA,EAAEnD,KAAI,CAACmC,EAAIiB,IAAmB,IAATA,EAAa,QAAQjB,QAASQ,OAAmB,GAAGR,OAAQkB,KAAK,OAAMA,KAAK,SAEpI,UAATZ,IACFQ,EAAiB,WAAWD,EAAOhD,KAAKmD,GAAMA,EAAEnD,KAAI,CAACmC,EAAIiB,IAAmB,IAATA,EAAa,QAAQjB,QAASQ,OAAmB,GAAGR,OAAQkB,KAAK,OAAMA,KAAK,SAEjJH,EAAgB,WAAWF,EAAOhD,KAAKmD,GAAMA,EAAEnD,KAAKmC,GAAO,GAAGA,OAAOkB,KAAK,OAAMA,KAAK,QAC9E,CAAEJ,iBAAgBC,gBAAe,EA6GpCI,EAAU,KACd,MAEMvE,EADJhB,EAAOiB,OAAOE,SAAWnB,EAAOmB,SAAWnB,EAAOiB,OAAOE,QAAQC,QAE/DpB,EAAOyB,OAAO+D,MACXpB,GACCA,EAAG9C,aAAa,8BACftB,EAAOiB,OAAOC,KACXlB,EAAOyF,UACPzF,EAAO0F,aACTC,aAEN3F,EAAOyB,OAAOzB,EAAO0F,aAEnB1C,EAAajC,EAAcC,GAC3B4C,EAAgB5D,EAAO4C,cAAe,EAAK,EACjD,GAAII,IAAelC,EACjB,OAEFA,EAAwBkC,EAExB,MAAM/B,EAASjB,EAAOiB,OAAOd,iBACvBM,cACJA,EAAaC,eACbA,EAAcC,YACdA,EAAWC,YACXA,EAAWC,YACXA,EAAWN,cACXA,EAAaC,aACbA,GACES,EAEE2E,EAAc5E,EAAQa,cAAc,2BACpCoB,EAAYjC,EAAQa,cAAc,wBAClCU,aAAEA,EAAYP,gBAAEA,EAAeK,gBAAEA,EAAeC,gBAAEA,GACtDX,EAAoBX,GAElB4E,IACFA,EAAY3B,MAAM4B,mBAAqB,MACvCD,EAAY3B,MAAM6B,yBAA2B,SAC7CF,EAAY3B,MAAMC,UAAY,GAAG1B,gBAE/BS,IACFA,EAAUgB,MAAM4B,mBAAqB,MACrCD,EAAY3B,MAAM6B,yBAA2B,SAC7C7C,EAAUgB,MAAMC,UAAY1B,GACtBjC,EAAgBqD,EAApB,MAGJrB,EAAa4B,SAASC,IACpBA,EAAGH,MAAM4B,mBAAqB,MAC9BzB,EAAGH,MAAMC,UAAY1B,GAAc,IAGlBxB,EAAQ+E,WAEvBH,IACFA,EAAY3B,MAAM4B,mBAAqB,GAAGpF,MAC1CmF,EAAY3B,MAAM6B,yBAA2B,SAC7CF,EAAY3B,MAAMC,UAAY,GAAG1B,aAAwB9B,MAEvDuC,IACFA,EAAUgB,MAAM4B,mBAAqB,GAAGpF,MACxCwC,EAAUgB,MAAM6B,yBAA2B,SAC3C7C,EAAUgB,MAAMC,UAAY,GAAG1B,EAAgBjC,EAAgBqD,EAAnB,cAA8CpD,MAE5F+B,EAAa4B,SAASC,IACpBA,EAAGH,MAAM4B,mBAAqB,GAAGpF,MACjC2D,EAAGH,MAAM6B,yBAA2B,QAAQ,IAG9C9D,EAAgBmC,SAASC,IACvBA,EAAGH,MAAMC,UAAY,GAAG1B,aAAwB7B,IAAc,IAEhE0B,EAAgB8B,SAASC,IACvBA,EAAGH,MAAMC,UAAY,GAAG1B,aAAwB5B,IAAc,IAEhE0B,EAAgB6B,SAASC,IACvBA,EAAGH,MAAMC,UAAY,GAAG1B,aAAwB3B,IAAc,GAC9D,EAGJ,IAAImF,GAAc,EA2BlB/F,EAAG,cAxNsBgG,IACvB,MAAMrB,EAAcqB,EAAEhF,OAAOd,gBAAgBE,oBACvC6F,EAAUD,EAAEhF,OAAOd,gBAAgBG,aACnCoC,EAAe1C,EAAO0C,eACtBG,EAAM7C,EAAO4C,aACnB5C,EAAOoE,GAAG+B,iBAAiB,qBAAqBhC,SAASC,IACvD,MAAMgC,EAAYhC,EAAGvC,cAAc,iCACnC,IAAKuE,EAAW,OAChBhC,EAAG+B,iBACD,qDACAhC,SAASkC,IACTA,EAAWC,QAAQ,IAGrB,MAAMC,EAAQzC,KAAKiB,SAAW,GACxB3B,GAAU,EAAoB,EAAhBU,KAAKiB,UAAgB,EACnCE,EAASvC,EACXG,EACE,CACE,CAAC0D,EAAQnD,EAAS,EAAG,GACrB,CAAC,IAAK,GACN,CAAC,IAAK,KACN,CAAEmD,EAAiB,EAATnD,EAAY,MAExB,CACE,CAAC,EAAG,GACJ,CAACmD,EAAQ,IAAMnD,EAAS,IAAK,GAC7B,CAAEmD,EAAuB,IAAf,IAAMnD,EAAc,KAC9B,CAAC,EAAG,MAER,CACE,CAAC,EAAG,GACJ,CAAC,IAAK,GACN,CAAC,IAAKmD,EAAQ,IAAMnD,EAAS,KAC7B,CAAC,EAAImD,EAAuB,IAAf,IAAMnD,IAEzBgB,EAAGH,MAAMuC,SAAW,WAAWvB,EAAOhD,KAAKmD,GAAMA,EAAEnD,KAAKmC,GAAO,GAAGA,OAAOkB,KAAK,OAAMA,KAAK,QACzF,MAAM1D,EAAc6E,SAASC,cAAc,OAC3C9E,EAAY+E,UAAUC,IAAI,wBAC1BxC,EAAGyC,YAAYjF,GAEf,MAAMxB,EAAY0D,KAAKC,IACrBD,KAAKgD,IAAI,EAAGb,EAAEhF,OAAOd,gBAAgBC,WACrC,GAIF,IAAK,IAAI8B,EAAI,EAAGA,EAAI9B,EAAW8B,GAAK,EAAG,CACrC,MAAM6E,EAAUX,EAAUY,WAAU,GAC9BC,EAAWR,SAASC,cAAc,OACxCK,EAAQJ,UAAUC,IAAI,uBACtBK,EAASN,UAAUC,IAAI,8BACvB,MAAM1B,eAAEA,EAAcC,cAAEA,GAAkBV,EACxC,OACAvC,EACA0C,GAEFqC,EAAShD,MAAMuC,SAAWtB,EAC1B6B,EAAQ9C,MAAMuC,SAAWrB,EACrBe,IACFa,EAAQ9C,MAAM9B,OAAS,QAAQD,EAAI,QAErCN,EAAYiF,YAAYI,GACxBrF,EAAYiF,YAAYE,EAChC,CAGM,IAAK,IAAI7E,EAAI,EAAGA,EAAI9B,EAAW8B,GAAK,EAAG,CACrC,MAAM6E,EAAUX,EAAUY,WAAU,GAC9BC,EAAWR,SAASC,cAAc,OACxCK,EAAQJ,UAAUC,IAAI,uBACtBK,EAASN,UAAUC,IAAI,8BACvB,MAAM1B,eAAEA,EAAcC,cAAEA,GAAkBV,EACxC,QACAvC,EACA0C,GAEFqC,EAAShD,MAAMuC,SAAWtB,EAC1B6B,EAAQ9C,MAAMuC,SAAWrB,EACrBe,IACFa,EAAQ9C,MAAM9B,OAAS,QAAQD,EAAI,QAErCN,EAAYiF,YAAYI,GACxBrF,EAAYiF,YAAYE,EAChC,IACM,IAoIJ9G,EAAG,QAPY,KACsB,IAA/BD,EAAOiB,OAAOiG,cAChB3B,GACN,IAKEtF,EAAG,YA3BgB,KACjB+F,GAAc,EACdmB,uBAAsB,KACpBnB,GAAc,CAAK,GACnB,IAwBJ/F,EAAG,mBArBuB,KACpB+F,GAGJT,GAAS,IAkBXtF,EAAG,iBAfqB,KApHAD,EAAOyB,OAAOU,QAAO,CAACiC,EAAIgD,IAC3BrG,EAAcqD,MACZpE,EAAOiB,OAAOC,KAC/BlB,EAAOyF,UACPzF,EAAO0F,eAICvB,SAAQ,CAACC,EAAIgD,KACzBhD,EAAG+B,iBACD,0DACAhC,SAASC,IACTA,EAAGH,MAAM4B,mBAAqB,MAC9BzB,EAAGH,MAAMC,UAAY,EAAE,GACvB,IAwGJqB,GAAS,IAcXtF,EAAG,gBAAiB0C,GC5btB,SAAoB1B,GAClB,MAAMoG,OACJA,EAAMrH,OACNA,EAAMC,GACNA,EAAE0C,aACFA,EAAY2E,cACZA,EAAaC,gBACbA,EAAeC,YACfA,EAAWC,gBACXA,EAAeC,gBACfA,GACEzG,EA+BJ,IAAI0G,EA9BJ1H,EAAG,cAAc,KACf,GAAID,EAAOiB,OAAOoG,SAAWA,EAAQ,OACrCrH,EAAO4H,WAAW5C,KAAK,GAAGhF,EAAOiB,OAAO4G,yBAAyBR,KAC7DG,GAAeA,KACjBxH,EAAO4H,WAAW5C,KAAK,GAAGhF,EAAOiB,OAAO4G,4BAE1C,MAAMC,EAAwBP,EAAkBA,IAAoB,GACpEQ,OAAOC,OAAOhI,EAAOiB,OAAQ6G,GAC7BC,OAAOC,OAAOhI,EAAOiI,eAAgBH,EAAsB,IAE7D7H,EAAG,gCAAgC,KAC7BD,EAAOiB,OAAOoG,SAAWA,GAC7B1E,GAAc,IAEhB1C,EAAG,iBAAiB,CAACiI,EAAIC,KACnBnI,EAAOiB,OAAOoG,SAAWA,GAC7BC,EAAca,EAAS,IAEzBlI,EAAG,iBAAiB,KAClB,GAAID,EAAOiB,OAAOoG,SAAWA,GACzBI,EAAiB,CACnB,IAAKC,IAAoBA,IAAkBU,aAAc,OAEzDpI,EAAOyB,OAAO0C,SAAQnD,IACpBA,EAAQmF,iBAAiB,gHAAgHhC,SAAQkE,GAAYA,EAAS/B,UAAS,IAGjLmB,GACN,KAGExH,EAAG,iBAAiB,KACdD,EAAOiB,OAAOoG,SAAWA,IACxBrH,EAAOyB,OAAOsB,SACjB4E,GAAyB,GAE3BR,uBAAsB,KAChBQ,GAA0B3H,EAAOyB,QAAUzB,EAAOyB,OAAOsB,SAC3DJ,IACAgF,GAAyB,EACjC,IACM,GAEN,CDsYEW,CAAW,CACTjB,OAAQ,aACRrH,SACAC,KACA0C,eACA2E,cAxTqBa,IACrB,MAAM1G,OAAEA,GAAWzB,EACnB,IAAK,IAAIkC,EAAI,EAAGA,EAAIT,EAAOsB,OAAQb,GAAK,EAAG,CACzC,MAAMlB,EAAUS,EAAOS,GAEvB,IAAIqG,EAAgB,GADDxH,EAAcC,KAEdF,IACjByH,EACE,oGAEJ,CACEvH,KACGA,EAAQmF,iBACT,2CAA2CoC,MAE7CpE,SAASC,IACTA,EAAGH,MAAM4B,mBAAqB,GAAGsC,KAAY,GAErD,EE1JA,SAAoCK,GAClC,IAAIxI,OACFA,EAAMmI,SACNA,EAAQM,kBACRA,GAEED,EACJ,MAAM9C,YACJA,GACE1F,EASJ,GAAIA,EAAOiB,OAAOyH,kBAAiC,IAAbP,EAAgB,CACpD,IACIQ,EADAC,GAAiB,EAGnBD,EAAsBF,EAOxBE,EAAoBxE,SAAQC,KC8QhC,SAA8BA,EAAIyE,GAM5BA,GACFzE,EAAG0E,iBAAiB,iBANtB,SAASC,EAAaC,GAChBA,EAAEC,SAAW7E,IACjByE,EAASK,KAAK9E,EAAI4E,GAClB5E,EAAG+E,oBAAoB,gBAAiBJ,GAC5C,GAIA,CDtRMK,CAAqBhF,GAAI,KACvB,GAAIwE,EAAgB,OACpB,IAAK5I,GAAUA,EAAOqJ,UAAW,OACjCT,GAAiB,EACjB5I,EAAOsJ,WAAY,EACnB,MAAMC,EAAM,IAAIzJ,OAAO0J,YAAY,gBAAiB,CAClDC,SAAS,EACTC,YAAY,IAEd1J,EAAO2J,UAAUC,cAAcL,EAAI,GACnC,GAER,CACA,CFgHIM,CAA2B,CACzB7J,SACAmI,WACAM,kBAAmBhH,GAEnB,EAiSF+F,YAAa,KAAM,EACnBD,gBAAiB,KACf,IAAIuC,EAAiB,GAUrB,OATI9J,EAAO+J,aAAaC,aACtBjC,OAAOkC,KAAKjK,EAAO+J,aAAaC,aAAa7F,SAAS+F,IACpDJ,EAAeI,GAAO,IACjBlK,EAAO+J,aAAaC,YAAYE,GACnCC,cAAe,EACfC,aAAc,EACf,IAGE,CACL1B,kBAAkB,EAElB2B,gBAAgB,EAChBC,eAAgB,EAChBH,cAAe,EACfI,qBAAqB,EACrBH,aAAc,EACdJ,YAAaF,EACd,GAGP,C"}